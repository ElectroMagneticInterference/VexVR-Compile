{
    "appVersion": "",
    "fileFormat": "1.0.0",
    "icon": "",
    "mode": "Text",
    "platform": "PG",
    "playground": "Grid Map",
    "rconfig": [],
    "sdkVersion": "",
    "slot": 0,
    "textContent": "#=+=+=+=+=+==+=+=+=+= Info +=+=+=+=+==+=+=+=+=+=#\n#                                               #\n# \tProject:      Universal threading           #\n#\tAuthor:       ElectroMagnetic Interference  #\n#\tCreated:      1/12/21                       #\n#\tDescription:                                #\n#       A Universal Solution to VEXVR,          #\n#       utilizing Threading for optimal speed   #\n#                                               #\n#=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=#\nfrom vexcode import *\n\ndef main(e):\n    e.init()\n\n    e.print(\"You can print stuff!\\nAnd Change the color!\\n\\n\", GREEN)\n    # move to specified coordinates!\n    e.move([30,77], [-777, 324], [900, -900])\n\n    # And much, much more!\n\n\n\n#=+=+=+= Reference\n#\n#   legend:\n#       e = the class with functions to do, it has a Arbitray variable name\n#       str::value: type :: what_it_is\n#       Coord: [int::x, int::y]\n#       *something: any amount of {something}\n#       (thing1|thing2): accepts either value\n#       something?: arg is optional\n#\n#   e.init(options?)\n#       Initalizes the program, and lets you choose the settings for the program.\n#\n#       ! This MUST be the first line of the main() function.\n#\n#       unit:   changes the unit the program is in (INCH|MM)\n#               defaults to MM\n#       strict: If True, syncs after every move,\n#           slows down the bot, but improves accuracy.\n#               defaults to False\n#\n#   e.move(*Coord)\n#\n#   e.pickup(Coord)\n#       active magnet, move to coord\n#   e.pickup(Coord, \"return\")\n#       normal, but returns to previous coord\n#   e.pickup(Coord, Coord)\n#       normal, but after first move, it goes to second.\n#\n#   e.drop(Coord)\n#       move to coord, deactive magnet\n#   e.drop(Coord, \"return\")\n#       normal, but returns to previous coord\n#   e.drop(Coord, Coord)\n#       normal, but after first move, it goes to second.\n#\n#   e.pen(*Color|Position)\n#       enter a Pen color or position, and it does that.\n#\n#   e.print(message, color?)\n#\n#   e.sync()\n#       syncs the threads to improve accuracy after a few moves.\n#\n#\n#=+=+=+=\n\n#!=+=+=+=+=+==+=+=+=+=+ BEWARE =+=+=+=+==+=+=+=+=+=!#\n#!                                                 !#\n#!  BEYOND THIS POINT, IS THE CODING STUFFS DON'T  !#\n#!  MESS WITH UNLESS YOU KNOW WHAT YOU ARE DOING,  !#\n#!  OR IF YOU JUST WANT TO                         !#\n#!                                                 !#\n#!=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=!#\nfrom vexcode import *\nimport math, re\nclass settings:\n    def __init__(self,unit=MM,strict=True):\n        self.unit = unit\n        self.strict = strict\n_coords=[]\n_calc_wait = True\n_move_wait = True\nclass create_coords:\n    dir = FORWARD\n    P_dir = \"Forward\"\n    def __init__(self, target, dir = None):\n        global _nextPosCoord, _current_angle\n        self.start = _nextPosCoord\n        _nextPosCoord = target\n        self.target = target\n        self.target_relative = [self.target[0] - self.start[0], self.target[1] - self.start[1]]\n        x = self.target_relative[0]\n        y = self.target_relative[1]\n        self.dist = math.sqrt(x*x+y*y)\n        self.P_dist = math.ceil(self.dist)\n        if x != 0 and y != 0: \n            self.angle = math.degrees(math.atan2(x, y))\n            if self.angle < 0:\n                self.angle += 360\n        elif y > 0: self.angle = 0\n        elif x > 0: self.angle = 90\n        elif y < 0: self.angle = 180\n        elif x < 0: self.angle = 270\n        else: raise Exception(f'The target coord is the same as the previous!\\n movement #{len(_coords)}')\n        angle_margin = [_current_angle - 90, _current_angle + 90]\n        for i in angle_margin:\n            if i < 0:\n                i += 360\n        if dir:\n            if dir == REVERSE:\n                self.dir = REVERSE\n                self.P_dir = \"Reverse\"\n                self.angle += 180\n        elif angle_margin[0] > self.angle < angle_margin[1]:\n            self.dir = REVERSE\n            self.P_dir = \"Reverse\"\n            self.angle += 180\n        _current_angle = self.angle\n        self.P_angle = math.ceil(self.angle)\nclass _calc:\n    def init(self,unit=MM,strict=False):\n        global _nextPosCoord, _current_angle, settings\n        settings = settings(unit=unit,strict=strict)\n        _nextPosCoord = [location.position(X,settings.unit), location.position(Y,settings.unit)]\n        _current_angle = location.position_angle(DEGREES)\n        _log.append(message(\"Initated\\n\\n\\n\", GREEN))\n    def __move(self,target,dir=None,log = False):\n        global _coords, _nextPosCoord\n        coord = create_coords(target, dir=dir)\n        if log: coord.log = log\n        elif log != None: coord.log = f\"Driving {coord.P_dir} from {coord.start} to {coord.target}\\n\\n\"\n        _nextPosCoord = target\n        _coords.append(coord)\n        if settings.strict:\n            self.__sync()\n        wait(3,MSEC)\n        return coord\n    def move(self,*targets):\n        for target in targets:\n            self.__move(target)\n    def __pickup_move(self, target, endpoint, log):\n        global _nextPosCoord\n        if endpoint == \"return\": _endPrint = _nextPosCoord\n        else: _endPrint = endpoint\n        log += f\" at {target}\\n\\tDriving Forward from {_nextPosCoord} to {target}\\n\"\n        if endpoint: log += f\"\\tThen, Driving Reverse from {target} to {_endPrint}\\n\\n\"\n        else: log += \"\\n\"\n        coord = self.__move(target, FORWARD, log)\n        if endpoint == \"return\": _nextPosCoord = coord.start\n        elif endpoint : self.__move(endpoint, log=None)\n    def pickup(self, target, endpoint=None):\n        log = \"Picking up item\"\n        self.__pickup_move(target, endpoint, log=log)\n    def drop(self, target, endpoint=None):\n        log = \"Dropping item off\"\n        self.__pickup_move(target, endpoint, log=log)\n    def __sync(self,*args):\n        global _calc_wait, _nextPosCoord, _move_wait\n        while _calc_wait:\n            wait(1,MSEC)\n        if not settings.strict: _log.append(message(\"Synced\\n\\n\", GREEN))\n        _nextPosCoord = [location.position(X,settings.unit), location.position(Y,settings.unit)]\n        _calc_wait = True\n        _move_wait = False\n        wait(1,MSEC)\n    def sync(self, *args):\n        if not settings.strict:\n            self.__sync()\n    def pen(*args):pass\n    def print(*args):pass\ndef _calculate():\n    main(_calc())\n    _end()\nclass _move:\n    def init(self,unit=MM,strict=False,*args1):\n        wait(1,MSEC)\n    def __move(self, *i):\n        global _move_finished, _log\n        coord = _coords[0]\n        drivetrain.turn_to_heading(coord.angle, DEGREES, True)\n        wait(1,MSEC)\n        drivetrain.drive_for(coord.dir, coord.dist, settings.unit)\n        try:\n            _log.append(message(coord.log))\n        except:\n            pass\n        _coords.pop(0)\n        if settings.strict:\n            self.__sync()\n        return coord\n    def move(self, *targets):\n        for i in range(len(targets)):\n            self.__move()\n    def pickup(self,target,endpoint=None,*args):\n        magnet.energize(BOOST)\n        coord = self.__move()\n        wait(1,MSEC)\n        if endpoint == \"return\": drivetrain.drive_for(REVERSE, coord.dist, settings.unit)\n        elif endpoint: self.__move()\n    def drop(self,target,endpoint=None,*args):\n        coord = self.__move()\n        wait(1,MSEC)\n        magnet.energize(DROP)\n        if endpoint == \"return\": drivetrain.drive_for(REVERSE, coord.dist, settings.unit)\n        elif endpoint: self.__move()\n    def __sync(self,*args1):\n        global _calc_wait, _move_wait\n        _calc_wait = False\n        if not settings.strict: _log.append(message(\"Syncing...\\n\", BLACK))\n        while _move_wait:\n            wait(1,MSEC)\n        _move_wait = True\n        while True:\n            try: \n                if _coords[0]: break\n            except: \n                wait(1,MSEC)\n    def sync(self, *args1):\n        if not settings.strict: self.__sync()\n    def pen(self,*args):\n        for arg in args:\n            if arg in [RED,GREEN,BLUE,BLACK]: pen.set_pen_color(arg)\n            elif arg in [UP,DOWN]: pen.move(arg)\n            else: raise Exception(f\"{arg} is not a pen action.\\nThe valid actions are...\\nChanging Color: [RED,GREEN,BLUE,BLACK]\\nor Changing Position: [UP,DOWN]\")\n            wait(1,MSEC)\n    def print(self, m, c = None):\n        _log.append(message(m,c,True))\ndef _movement():\n    drivetrain.set_drive_velocity(100,PERCENT)\n    drivetrain.set_turn_velocity(100,PERCENT)\n    wait(3,MSEC)\n    main(_move())\n    _end()\nclass message:\n    def __init__(self, message, color=None, user=False):\n        self.message = message\n        self.color = color\n        self.user = user\n_log= []\n_log_color= BLACK\ndef _misc():\n    global _threads_active\n    brain.clear()\n    brain.set_print_color(BLACK)\n    def log():\n        global _log, _log_color\n        if _log[0]:\n            if _log[0].color: color = _log[0].color\n            else: color = _log_color\n            brain.set_print_color(color)\n            if not _log[0].user:\n                if _log_color == BLACK: _log_color = BLUE \n                else: _log_color = BLACK\n            try: \n                brain.print(_log[0].message)\n            except: \n                brain.print(_log[0])\n            _log.pop(0)\n    while _threads_active:\n        try:\n            log()\n            wait(1,MSEC)\n        except:\n            wait(5,MSEC)\n    log()\n    _end()\n_threads_active = True\n_end_tracker = 0\ndef _end():\n    global _end_tracker, _threads_active\n    _end_tracker += 1\n    if _end_tracker >= 2:\n        _threads_active = False\n    if _end_tracker >= 3:\n        brain.set_print_color(GREEN)\n        brain.print(f\"\\n\\nTime Elasped: {brain.timer_time(SECONDS)}\")\n        stop_project()\nvr_thread(_calculate())\nvr_thread(_movement())\nvr_thread(_misc())\n",
    "textLanguage": "python"
}