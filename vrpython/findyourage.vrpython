{
    "appVersion": "",
    "fileFormat": "1.0.0",
    "icon": "",
    "mode": "Text",
    "platform": "PG",
    "playground": "Number Grid Map",
    "rconfig": [],
    "sdkVersion": "",
    "slot": 0,
    "textContent": "\n#=+=+=+=+=+==+=+=+=+= Info +=+=+=+=+==+=+=+=+=+=#\n#                                               #\n# \tProject:      Find Your Age                 #\n#\tAuthor:       ElectroMagnetic Interference  #\n#\tCreated:      1/28/21                       #\n#\tDescription:                                #\n#       A Universal Solution to the \"find your  #\n#       age\" task using Universal Threading     #\n#                                               #\n#=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=#\nfrom vexcode import *\n\ndef num(e,num,col=BLACK):\n    num = str(num - 1)\n\n    if len(num) == 1:\n        num = f\"0{num}\"\n\n    x = (int(num[1]))*200-950\n    y = int(num[0])*200-950\n\n    e.move([x,y])\n\n    e.pen(DOWN, col)\n\n    e.move([x+100,y+100])\n\n    e.pen(UP)\n\ndef age(e,year):\n    num(e,year,GREEN)\n\n    num(e,35 - year,BLACK)\n\ndef main(e):\n    e.init()\n\n    day = 1     #day\n    month = 13  #month\n    year = 97   #year\n    #day (blue)\n    num(e,day,BLUE)\n\n    #month (red)\n    num(e,month,RED)\n\n    #year (green) and age in 2035 (black)\n    age(e,year)\n\n    e.move([0,0])\n\n\n\n\n# =+=+=+= Reference\n#\n#   legend:\n#       e = the class with functions to do, it has a Arbitray variable name\n#       str::value: type :: what_it_is\n#       Coord: [int::x, int::y]\n#       *something: any amount of {something}\n#       (thing1|thing2): accepts either value\n#       something?: arg is optional\n#\n#   e.init(options?)\n#       Initalizes the program, and lets you choose the settings for the program.\n#\n#       ! This MUST be the first line of the main() function.\n#\n#       unit:   changes the unit the program is in (INCH|MM)\n#               defaults to MM\n#       strict: If True, syncs after every move,\n#           slows down the bot, but improves accuracy.\n#               defaults to False\n#\n#   e.move(*Coord)\n#\n#   e.pickup(Coord)\n#       active magnet, move to coord\n#   e.pickup(Coord, \"return\")\n#       normal, but returns to previous coord\n#   e.pickup(Coord, Coord)\n#       normal, but after first move, it goes to second.\n#\n#   e.drop(Coord)\n#       move to coord, deactive magnet\n#   e.drop(Coord, \"return\")\n#       normal, but returns to previous coord\n#   e.drop(Coord, Coord)\n#       normal, but after first move, it goes to second.\n#\n#   e.pen(*Color|Position)\n#       enter a Pen color or position, and it does that.\n#\n#   e.print(message, color?)\n#\n#   e.sync()\n#       syncs the threads to improve accuracy after a few moves.\n#\n#\n# =+=+=+=\n\n#!=+=+=+=+=+==+=+=+=+=+ BEWARE =+=+=+=+==+=+=+=+=+=!#\n#!                                                 !#\n#!  BEYOND THIS POINT, IS THE CODING STUFFS DON'T  !#\n#!  MESS WITH UNLESS YOU KNOW WHAT YOU ARE DOING,  !#\n#!  OR IF YOU JUST WANT TO                         !#\n#!                                                 !#\n#!=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=!#\n\n# =+=+=+==+=+=+= The Program\n\"\"\"\nStarts 3 Seperate threads each with their own specific tasks.\nThe threads all interact in specific ways to ensure that the robot goes as fast as possible.\n\"\"\"\n\n# =+=+=+= Library Imports\nfrom vexcode import *\nimport math\n\n# =+=+=+=\n\n# =+=+=+= Settings Class\nclass settings:\n    def __init__(self, unit=MM, strict=True):\n        self.unit = unit\n        self.strict = strict\n\n\n# =+=+=+=\n\n# =+=+=+= Calculation Thread\n\"\"\"\nThe _calculate() thread calculates the angles\n    and positions, then stores them for the _movement()\n    thread to use when it gets there.\n\n    This thread needs to be able to effectively calculate\n    the movements needed to do the actions in _main()\n\"\"\"\n_coords = []\n_calc_wait = True\n_move_wait = True\n\"\"\"\nThis class is utilized by the preprocessor to calculate the\ndistances and angles from the coordinates given.\n\"\"\"\n\n\nclass create_coords:\n    # pre established values for the direction\n    dir = FORWARD\n    P_dir = \"Forward\"\n\n    # activate function when class is created.\n    def __init__(self, target, dir=None):\n        \"\"\"\n        The _nextPosCoord is not ideal, but it is the best way I could find\n        to preprocess the values. The future _tolerance() thread should dynamically fix\n        the issues if they arrise.\n        \"\"\"\n        global _nextPosCoord, _current_angle\n        # sets the coordinates started from as the _nextPosCoord {needs better name} value.\n        self.start = _nextPosCoord\n        # sets the _nextPosCoord value to the target value, for the next coord to use.\n        _nextPosCoord = target\n\n        self.target = target\n\n        # translate the orgin to the current position, and everything else by that translation.\n        # subtract the current position by the position the orgin is Driving to.\n        self.target_relative = [\n            self.target[0] - self.start[0],\n            self.target[1] - self.start[1],\n        ]\n        x = self.target_relative[0]\n        y = self.target_relative[1]\n\n        # find the length of the new target vector, using sqr(x^2+y^2)\n        self.dist = math.sqrt(x * x + y * y)\n\n        # round it for logging purposes\n        self.P_dist = math.ceil(self.dist)\n\n        \"\"\"\n        Calculates the angle, relative to the x axis, of the vector from the bot's position\n        to the destination coords.\n        Gets the angle of the vector\n        the math for it is explained on the github page\n        \"\"\"\n        if x != 0 and y != 0:\n            self.angle = math.degrees(math.atan2(x, y))\n            # if angle is negative, add 360\n            if self.angle < 0:\n                self.angle += 360\n        # if the angle is a multiple of 90\n        elif y > 0:\n            self.angle = 0\n        elif x > 0:\n            self.angle = 90\n        elif y < 0:\n            self.angle = 180\n        elif x < 0:\n            self.angle = 270\n\n        # throw error if the coords are the same as the starting coords.\n        else:\n            raise Exception(\n                f\"The target coord is the same as the previous!\\n movement #{len(_coords)}\"\n            )\n\n        angle_margin = [_current_angle - 90, _current_angle + 90]\n        for i in angle_margin:\n            if i < 0:\n                i += 360\n\n        if dir:\n            if dir == REVERSE:\n                self.dir = REVERSE\n                self.P_dir = \"Reverse\"\n                self.angle += 180\n\n        elif angle_margin[0] > self.angle < angle_margin[1]:\n            self.dir = REVERSE\n            self.P_dir = \"Reverse\"\n            self.angle += 180\n\n        _current_angle = self.angle\n\n        self.P_angle = math.ceil(self.angle)\n\n\n\"\"\"\nThis class is given to the main() function to use.\nThis class defines the preprocessor versions of the functions used in main\n\"\"\"\n\n\nclass _calc:\n    def init(self, unit=MM, strict=False):\n        global _nextPosCoord, _current_angle, settings\n        settings = settings(unit=unit, strict=strict)\n        _nextPosCoord = [\n            location.position(X, settings.unit),\n            location.position(Y, settings.unit),\n        ]\n        _current_angle = location.position_angle(DEGREES)\n        _log.append(message(\"Initated\\n\\n\\n\", GREEN))\n\n    \"\"\"\n    the 'hidden' function which the other functions use to move.\n    this function has more options for the program then is needed\n    for the user.\n    \"\"\"\n\n    def __move(self, target, dir=None, log=False):\n        global _coords, _nextPosCoord\n        coord = create_coords(target, dir=dir)\n        if log:\n            coord.log = log\n        elif log != None:\n            coord.log = (\n                f\"Driving {coord.P_dir} from {coord.start} to {coord.target}\\n\\n\"\n            )\n        _nextPosCoord = target\n        _coords.append(coord)\n        if settings.strict:\n            self.__sync()\n        wait(3, MSEC)\n        return coord\n\n    \"\"\"\n    The move function used by people, this can accept many coordinates\n    for each coordinate given, it activates the __move() function with\n    that value\n    \"\"\"\n\n    def move(self, *targets1):\n        for target in targets1:\n            self.__move(target)\n\n    # Function used by pickup() and drop()\n    def __pickup_move(self, target, endpoint, log):\n        global _nextPosCoord\n        # activate __move() with the first coord value\n        if endpoint == \"return\":\n            _endPrint = _nextPosCoord\n        else:\n            _endPrint = endpoint\n        log += f\" at {target}\\n\\tDriving Forward from {_nextPosCoord} to {target}\\n\"\n        if endpoint:\n            log += f\"\\tThen, Driving Reverse from {target} to {_endPrint}\\n\\n\"\n        else:\n            log += \"\\n\"\n\n        coord = self.__move(target, FORWARD, log)\n        \"\"\"\n        checks if there is an endpoint value,\n        if it equals \"return\" go to starting coord\n        else, go to the coord specified.\n        \"\"\"\n        if endpoint == \"return\":\n            _nextPosCoord = coord.start\n        elif endpoint:\n            self.__move(endpoint, log=None)\n\n    \"\"\"\n    pickup and drop are identical to the preprocessor,\n    besides their name, and their logging value.\n    \"\"\"\n\n    def pickup(self, target, endpoint=None):\n        # base log value, rest is added on as its identical to self.drop()\n        log = \"Picking up item\"\n        self.__pickup_move(target, endpoint, log=log)\n\n    def drop(self, target, endpoint=None):\n        log = \"Dropping item off\"\n        self.__pickup_move(target, endpoint, log=log)\n\n    \"\"\"\n    The sync cosettings.unitand is arguabully the most usefill cosettings.unitand.\n    This cosettings.unitand stops the _calculate() thread until the _movement()\n    thread catches up. This also resets the position know to the\n    _calculate() thread, so it can reajust its position and improve accuracy.\n    \"\"\"\n\n    def __sync(self, *args):\n        global _calc_wait, _nextPosCoord, _move_wait\n        while _calc_wait:\n            wait(1, MSEC)\n        if not settings.strict:\n            _log.append(message(\"Synced\\n\\n\", GREEN))\n        _nextPosCoord = [\n            location.position(X, settings.unit),\n            location.position(Y, settings.unit),\n        ]\n        _calc_wait = True\n        _move_wait = False\n        wait(1, MSEC)\n\n    def sync(self, *args):\n        if not settings.strict:\n            self.__sync()\n\n    # this is unused in the preprocessor, but is required to not throw errors\n    def pen(*args):\n        pass\n\n    def print(*args):\n        pass\n\n\ndef _calculate():\n    main(_calc())\n    _end()\n\n\n# =+=+=+=\n\n# =+=+=+= Movement Thread\n\"\"\"\nThe _movement() thread takes the stored values\n    from the _calculate() thread, then inteperatest\n    the value, finally actually doing them.\n\n    This thread is ment to be as fast as possible,\n    taking as little time between movements as possible.\n    When currently in movement, the other threads have\n    time to do what they need.\n\"\"\"\n\n\nclass _move:\n    def init(self, unit=MM, strict=False, *args1):\n        wait(1, MSEC)\n\n    def __move(self, *i):\n        global _log\n        # gets coord calculated in _calculate()\n        coord = _coords[0]\n\n        # turns and moves as specified\n        drivetrain.turn_to_heading(coord.angle, DEGREES, True)\n        wait(1, MSEC)\n        drivetrain.drive_for(coord.dir, coord.dist, settings.unit)\n\n        # pops coords used, and send data to logs.\n        try:\n            _log.append(message(coord.log))\n        except:\n            pass\n        _coords.pop(0)\n        if settings.strict:\n            self.__sync()\n        return coord\n\n    def move(self, *targets):\n        # repeats following function for the amount of\n        # parameters in targets\n        for i in range(len(targets)):\n            self.__move()\n\n    def pickup(self, target, endpoint=None, *args):\n        magnet.energize(BOOST)\n        # initalizes move, no paramets as its precalculated\n        coord = self.__move()\n        wait(1, MSEC)\n        if endpoint == \"return\":\n            drivetrain.drive_for(REVERSE, coord.dist, settings.unit)\n        elif endpoint:\n            self.__move()\n\n    # same as pickup() but different magnet usage\n    def drop(self, target, endpoint=None, *args):\n        coord = self.__move()\n        wait(1, MSEC)\n        magnet.energize(DROP)\n        if endpoint == \"return\":\n            drivetrain.drive_for(REVERSE, coord.dist, settings.unit)\n        elif endpoint:\n            self.__move()\n\n    # This is the action side of the sync() cosettings.unitand\n    def __sync(self, *args1):\n        global _calc_wait, _move_wait\n        _calc_wait = False\n        if not settings.strict:\n            _log.append(message(\"Syncing...\\n\", BLACK))\n        while _move_wait:\n            wait(1, MSEC)\n        _move_wait = True\n        while True:\n            try:\n                if _coords[0]:\n                    break\n            except:\n                wait(1, MSEC)\n\n    def sync(self, *args1):\n        if not settings.strict:\n            self.__sync()\n\n    # controls the pen\n    def pen(self, *args):\n        for arg in args:\n            if arg in [RED, GREEN, BLUE, BLACK]:\n                pen.set_pen_color(arg)\n            elif arg in [UP, DOWN]:\n                pen.move(arg)\n            else:\n                raise Exception(\n                    f\"{arg} is not a pen action.\\nThe valid actions are...\\nChanging Color: [RED,GREEN,BLUE,BLACK]\\nor Changing Position: [UP,DOWN]\"\n                )\n            wait(1, MSEC)\n\n    # print commands\n    def print(self, m, c=None):\n        _log.append(message(m, c, True))\n\n\ndef _movement():\n    # inital setup!\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    # this has to wait long enough for _calculation() thread\n    # to calculate the first movement.\n    wait(3, MSEC)\n    main(_move())\n    _end()\n\n\n# =+=+=+=\n\n# =+=+=+= Misc Thread\n\"\"\"\nThe _misc() thread waits for things to appear\n    in _log, once it does, it logs the value, cycles\n    the color, then pops the log value.\n\n! This is important, as without it, it takes away\n    ! alot of time from the other threads, and you cannot\n    ! print within class functions, which most of this\n    ! Program is.\n\"\"\"\n\n\nclass message:\n    def __init__(self, message, color=None, user=False):\n        self.message = message\n        self.color = color\n        self.user = user\n\n\n_log = []\n_log_color = BLACK\n\n\ndef _misc():\n    global _threads_active\n    brain.clear()\n    brain.set_print_color(BLACK)\n\n    def log():\n        global _log, _log_color\n        if _log[0]:\n            if _log[0].color:\n                color = _log[0].color\n            else:\n                color = _log_color\n            brain.set_print_color(color)\n            if not _log[0].user:\n                if _log_color == BLACK:\n                    _log_color = BLUE\n                else:\n                    _log_color = BLACK\n\n            try:\n                brain.print(_log[0].message)\n            except:\n                brain.print(_log[0])\n            _log.pop(0)\n\n    while _threads_active:\n        try:\n            log()\n            wait(1, MSEC)\n        except:\n            wait(5, MSEC)\n    log()\n    _end()\n\n\n# =+=+=+=\n\n# -- testing\n# #=+=+=+= Tolerance Testing Thread\n#\n# _Finshed_coords = []\n# _move_finished = None\n# def _tolerance():\n#     global _move_finished, _threads_active\n#     while _threads_active:\n#         while not _move_finished:\n#             wait(5, MSEC)\n#\n#         _Finshed_coords.append(_move_finished)\n#         brain.print(_move_finished.log)\n#         _move_finished = None\n#     _end()\n# #=+=+=+=\n# -- testing\n\n# =+=+=+= Ending\n\"\"\"\nThis function activates at the end of every thread.\n\n    The _calculate() and _movement() threads are always\n    the first to deactive. Once they do, they both call\n    this function, which will keep a tab of how many\n    threads have activated it. Once, both the _calculate()\n    and _movement() threads have ended, this will tell the\n    other threads to initate their final actions.\n\"\"\"\n_threads_active = True\n_end_tracker = 0\n\n\ndef _end():\n    global _end_tracker, _threads_active\n    _end_tracker += 1\n    if _end_tracker >= 2:\n        _threads_active = False\n    if _end_tracker >= 3:\n        brain.set_print_color(GREEN)\n        brain.print(f\"\\n\\nTime Elasped: {brain.timer_time(SECONDS)}\")\n        stop_project()\n\n\n# =+=+=+=\n\n# =+=+=+= Starting\nvr_thread(_calculate())\nvr_thread(_movement())\nvr_thread(_misc())\n\n\n# =+=+=+= EXPERIMENTAL\n# These next ones are still in testing.\n\n# vr_thread(_tolerance())\n\"\"\"\nThe _tolerance() thread receives information at the end\n    of each movement, and checks if they are in acceptable\n    tolerance. If the current angle or coords are outside\n    of the tolerance range, it will print a warning, and\n    have the _calculation() thread recalculate the movements\n    from that point forward.\n\"\"\"\n",
    "textLanguage": "python"
}